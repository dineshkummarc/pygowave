
#
# PyGoWave Server - The Python Google Wave Server
# Copyright 2009 Patrick Schneider <patrick.p2k.schneider@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# PyGoWave Client-to-Server Message Processor

import sys, datetime, logging

from django.contrib import auth
from django.core.exceptions import ObjectDoesNotExist
from django.conf import settings

from pygowave_server.models import Participant, ParticipantConn, Wave, Gadget, GadgetElement, Delta
from pygowave_server.common.operations import OpManager, WAVELET_REMOVE_PARTICIPANT, WAVELET_ADD_PARTICIPANT

__all__ = ["PyGoWaveClientMessageProcessor"]

# Progress tracker - implemented messages
# Legend:
# (sync)  - message is handled synchronously i.e. the client does not perform
#           any actions and waits for the server's response
# (async) - message is handled asynchronously and the server does not care if
#           there are inconsistencies
# (OT)    - full Operational Transformation implemented
#
# --------
#
# WAVELET_OPEN (sync)
# PARTICIPANT_INFO (sync)
# PARTICIPANT_SEARCH (sync)
# GADGET_LIST (sync)
# OPERATION_MESSAGE_BUNDLE (OT)
#   WAVELET_ADD_PARTICIPANT
#   WAVELET_REMOVE_PARTICIPANT
#   DOCUMENT_INSERT
#   DOCUMENT_DELETE
#   DOCUMENT_ELEMENT_INSERT
#   DOCUMENT_ELEMENT_DELETE
#   DOCUMENT_ELEMENT_DELTA
#   DOCUMENT_ELEMENT_SETPREF
# -> OPERATION_MESSAGE_BUNDLE_ACK

class PyGoWaveClientMessageProcessor(object):
	"""
	Handle all incoming messages.
	
	Routing key structure:
	<participant_conn_guid>.<wavelet_id>.[waveop|clientop]
	
	participant_conn_guid is created every time the user enters the wave viewer.
	Multiple instances of the wave viewer can be opened per user at the same time.
	A participant can "listen" to messages from multiple wavlets, by subscribing
	to multiple routing keys.
	In this scenario, a message may be sent to a queue, that the participant has
	not subscribed to. This is intended and it's RabbitMQ's job to drop the
	message. This keeps things simple for now and may be changed in the future.
	
	The guid is generated by the uuid library and should be unique for every
	connection. In practice any string could be used up	to 42 characters.
	
	Message comsumers can be optimized in a multi-threading environment. If
	one consumer starts handling messages of a particular wavelet, it should
	block others from handling them.
	
	Some messages are handled synchronously (i.e. the client does not perform
	any actions and waits for the server's response). See the list above.
	
	Special routing keys:
	- <participant_conn_guid>.manager.[waveop|clientop]
	  Used for special non-wavelet messages
	- <participant_conn_guid>.login.[waveop|clientop]
	  Used for authentication via client protocol
	
	"""
	
	logger = logging.getLogger("pygowave")
	conn_lifetime = datetime.timedelta(minutes=getattr(settings, "ACCESS_KEY_TIMEOUT_MINUTES", 2))
	
	def __init__(self):
		self.bundles = 0
		self.curr_connections = set()
		self.peak_connections = 0
		self.total_connections = 0

	def process(self, routing_key, message_data):
		"""
		Process a message in JSON format with the given routing key (= sender ID).
		This function may generate new messages which should be sent by the caller.
		The returned message dictionary has the form {routing_key: message, ...}.
		"""
		
		participant_conn_key, wavelet_id, message_category = routing_key.split(".")
		
		if message_category != "clientop":
			return {}
		
		if wavelet_id != "login":
			self.logger.debug("Received Message from %s.%s.%s:\n%s" % (participant_conn_key, wavelet_id, message_category, repr(message_data)))
		else:
			self.logger.debug("Received Login Message from %s" % (participant_conn_key))
		
		if not isinstance(message_data, list):
			message_data = [message_data]
		
		# Get participant connection
		if wavelet_id != "login":
			try:
				pconn = ParticipantConn.objects.get(tx_key=participant_conn_key)
				if pconn.id not in self.curr_connections:
					self.curr_connections.add(pconn.id)
					self.total_connections += 1
					if self.peak_connections < len(self.curr_connections):
						self.peak_connections = len(self.curr_connections)
			except ObjectDoesNotExist:
				return self.reply_error(participant_conn_key, wavelet_id, "NO_CONNECTION", "Not logged in or disconnected by server")
		
		self.out_queue = {}
		self.manager_queue = {}
		
		if wavelet_id == "login": # Login message?
			
			pconn = ParticipantConn(rx_key=participant_conn_key, tx_key=participant_conn_key)
			for sub_message in message_data:
				try:
					self.handle_login_message(pconn, sub_message)
				except:
					self.logger.exception("{%s} Exception in login message handler" % (routing_key))
					self.error(pconn, "EXCEPTION_IN_HANDLER", "The login message handler has thrown an exeption")
				break
			
		elif wavelet_id == "manager": # Management message?
			
			for sub_message in message_data:
				try:
					if not self.handle_management_message(pconn, sub_message): break
				except:
					self.logger.exception("{%s} Exception in management message handler" % (routing_key))
					self.error(pconn, "EXCEPTION_IN_HANDLER", "The management message handler has thrown an exeption")
		else:
			# Get wavelet
			try:
				wavelet = pconn.participant.wavelets.get(id=wavelet_id)
			except ObjectDoesNotExist:
				self.logger.error("{%s} Wavelet not found (or not participating)" % (routing_key))
				return self.reply_error(participant_conn_key, wavelet_id, "WAVELET_NOT_AVAILABLE", "Wavelet not found or not participating")
			
			# Handle message and reply to sender and/or broadcast an event
			for sub_message in message_data:
				try:
					if not self.handle_participant_message(wavelet, pconn, sub_message): break
				except:
					self.logger.exception("{%s} Exception in participant message handler" % (routing_key))
					self.error(pconn, "EXCEPTION_IN_HANDLER", "The participant message handler has thrown an exeption")
		
		# Build message dictionary
		msg_dict = {}
		for receiver, messages in self.out_queue.iteritems():
			msg_dict["%s.%s.waveop" % (receiver, wavelet_id)] = messages
		# Special manager messages
		for receiver, messages in self.manager_queue.iteritems():
			msg_dict["%s.manager.waveop" % (receiver)] = messages
		self.out_queue = {}
		self.manager_queue = {}
		
		return msg_dict
	
	def handle_participant_message(self, wavelet, pconn, message):
		"""
		Handle a participant's operation.
		If True is returned, go on with processing the next message.
		If False is returned, discard any following messages.
		
		"""
		participant = pconn.participant
		pconn.last_contact = datetime.datetime.now()
		pconn.save()
		
		if message.has_key(u"type"):
			
			if message["type"] == "PING": # DEPRECATED: Use the manager!
				self.emit(pconn, "PONG", message["property"]) # Traditionally
			
			elif message["type"] == "WAVELET_OPEN":
				self.logger.info("[%s/%s@%s] Opening wavelet" % (participant.name, pconn.id, wavelet.wave.id))
				pconn.wavelets.add(wavelet)
				# I know this is neat :)
				self.emit(pconn, "WAVELET_OPEN", {
					"wavelet": wavelet.serialize(),
					"blips": wavelet.serialize_blips(),
				})
			
			elif message["type"] == "WAVELET_CLOSE":
				# No reply
				pconn.wavelets.remove(wavelet)
				self.logger.info("[%s/%s@%s] Connection to wavelet closed (by client)" % (participant.name, pconn.id, wavelet.wave.id))
				return False
			
			elif message["type"] == "PARTICIPANT_INFO": # DEPRECATED: Moved to manager!
				self.logger.info("[%s/%s@%s] Sending participant information" % (participant.name, pconn.id, wavelet.wave.id))
				p_info = {}
				for p_id in message["property"]:
					try:
						p_info[p_id] = Participant.objects.get(id=p_id).serialize()
					except ObjectDoesNotExist:
						p_info[p_id] = None
				self.emit(pconn, "PARTICIPANT_INFO", p_info)
			
			elif message["type"] == "PARTICIPANT_SEARCH": # DEPRECATED: Moved to manager!
				if len(message["property"]) < getattr(settings, "PARTICIPANT_SEARCH_LENGTH", 0):
					self.emit(pconn, "PARTICIPANT_SEARCH", {"result": "TOO_SHORT", "data": getattr(settings, "PARTICIPANT_SEARCH_LENGTH", 0)})
					self.logger.debug("[%s/%s@%s] Participant search query too short" % (participant.name, pconn.id, wavelet.wave.id))
				else:
					self.logger.info("[%s/%s@%s] Performing participant search" % (participant.name, pconn.id, wavelet.wave.id))
					
					lst = []
					for p in Participant.objects.filter(name__icontains=message["property"]).exclude(id=participant.id):
						lst.append(p.id)
					self.emit(pconn, "PARTICIPANT_SEARCH", {"result": "OK", "data": lst})
			
			elif message["type"] == "GADGET_LIST": # DEPRECATED: Moved to manager!
				all_gadgets = map(lambda g: {"id": g.id, "uploaded_by": g.by_user.participants.all()[0].name, "name": g.title, "descr": g.description, "url": g.url}, Gadget.objects.all())
				self.logger.info("[%s/%s@%s] Sending Gadget list" % (participant.name, pconn.id, wavelet.wave.id))
				self.emit(pconn, "GADGET_LIST", all_gadgets)
			
			elif message["type"] == "WAVELET_ADD_PARTICIPANT": # DEPRECATED: Moved to OPERATION_MESSAGE_BUNDLE 
				# Find participant
				try:
					p = Participant.objects.get(id=message["property"])
				except ObjectDoesNotExist:
					self.emit(pconn, "ERROR", {"tag": "PARTICIPANT_NOT_FOUND", "desc": "A participant with id '%s' does not exist" % message["property"]})
					self.logger.error("[%s/%s@%s] Target participant '%s' not found" % (participant.name, pconn.id, wavelet.wave.id, message["property"]))
					return True
				# Check if already participating
				if wavelet.participants.filter(id=message["property"]).count() > 0:
					self.emit(pconn, "ERROR", {"tag": "PARTICIPANT_ALREADY_IN", "desc": "The participant with id '%s' already takes part" % message["property"]})
					self.logger.error("[%s/%s@%s] Target participant '%s' already there" % (participant.name, pconn.id, wavelet.wave.id, message["property"]))
					return True
				wavelet.participants.add(p)
				self.logger.info("[%s/%s@%s] Added new participant '%s'" % (participant.name, pconn.id, wavelet.wave.id, message["property"]))
				self.broadcast(wavelet, "WAVELET_ADD_PARTICIPANT", message["property"], [], {"id": message["property"]})
				
			elif message["type"] == "WAVELET_REMOVE_SELF": # DEPRECATED: Moved to OPERATION_MESSAGE_BUNDLE
				self.broadcast(wavelet, "WAVELET_REMOVE_PARTICIPANT", participant.id, [], {"id": participant.id})
				wavelet.participants.remove(participant) # Bye bye
				if pconn.wavelets.filter(id=wavelet.id).count() > 0:
					pconn.wavelets.remove(wavelet) # Also for your connection
				self.logger.info("[%s/%s@%s] Participant removed himself" % (participant.name, pconn.id, wavelet.wave.id))
				if wavelet.participants.count() == 0: # Oh my god, you killed the Wave! You bastard!
					self.logger.info("[%s/%s@%s] Wave got killed!" % (participant.name, pconn.id, wavelet.wave.id))
					wavelet.wave.delete()
				return False
			
			elif message["type"] == "OPERATION_MESSAGE_BUNDLE":
				self.bundles += 1
				
				# Build OpManager
				newdelta = OpManager(wavelet.wave.id, wavelet.id, participant.id)
				newdelta.unserialize(message["property"]["operations"])
				version = message["property"]["version"]
				
				# Transform
				for delta in wavelet.deltas.filter(version__gt=version):
					for op in delta.getOpManager().operations:
						newdelta.transform(op) # Trash results (an existing delta cannot be changed)
				
				i = 0
				added = []
				while i < len(newdelta.operations):
					op = newdelta.operations[i]
					if op.type == WAVELET_REMOVE_PARTICIPANT: # Check self removal, prevent removal of others
						if op.property != participant.id:
							self.logger.error("[%s/%s@%s] Participant tried to remove '%s'" % (participant.name, pconn.id, wavelet.wave.id, op.property))
							newdelta.removeOperation(i)
							continue
						self.broadcast_managers(wavelet, "WAVELET_REMOVE_PARTICIPANT", {"id": op.property}, [pconn], False)
						pconn.wavelets.remove(wavelet) # Remove connection
					elif op.type == WAVELET_ADD_PARTICIPANT:
						added.append(op.property)
					i += 1
				
				# Apply
				newblips = wavelet.applyOperations(newdelta.operations, participant)
				
				# Send manager messages for added participants
				for id in added:
					self.broadcast_managers(wavelet, "WAVELET_ADD_PARTICIPANT", {"id": id}, [pconn])
				
				# Raise version and store
				wavelet.version += 1
				wavelet.save()
				
				delta = Delta.createByOpManager(newdelta, wavelet.version)
				delta.save()
				
				# Create tentative checksums
				blipsums = wavelet.blipsums()
				
				# Respond
				self.emit(
					pconn,
					"OPERATION_MESSAGE_BUNDLE_ACK",
					{
						"version": wavelet.version,
						"blipsums": blipsums,
						"timestamp": delta.timestampMs(),
						"newblips": newblips
					}
				)
				self.broadcast(
					wavelet,
					"OPERATION_MESSAGE_BUNDLE",
					{
						"version": wavelet.version,
						"operations": newdelta.serialize(),
						"blipsums": blipsums,
						"timestamp": delta.timestampMs(),
						"contributor": newdelta.contributorId
					},
					[pconn]
				)
				
				self.logger.debug("[%s/%s@%s] Processed delta #%d -> v%d" % (participant.name, pconn.id, wavelet.wave.id, version, wavelet.version))
				
				if wavelet.participants.count() == 0: # Wavelet has no participants -> kill it
					if wavelet.is_root: # Oh my god, you killed the root Wavelet! You bastard!
						wavelet.wave.delete()
						self.logger.info("[%s/%s@%s] Wave got killed!" % (participant.name, pconn.id, wavelet.wave.id))
					else: # Ok, another one bites the dust
						wavelet.delete()
						self.logger.info("[%s/%s@%s] Wavelet got killed!" % (participant.name, pconn.id, wavelet.id))
				
			else:
				self.emit(pconn, "ERROR", {"tag": "UNKNOWN_MESSAGE", "desc": "Type '%s' not recognised" % message["type"]})
				self.logger.error("[%s/%s@%s] Unknown message: %s" % (participant.name, pconn.id, wavelet.wave.id, message))
		
		else:
			self.emit(pconn, "ERROR", {"tag": "UNKNOWN_MESSAGE", "desc": "Message lacks 'type' field"})
			self.logger.error("[%s/%s@%s] Unknown message: %s" % (participant.name, pconn.id, wavelet.wave.id, message))
		
		return True
	
	def handle_management_message(self, pconn, message):
		"""
		Handle a non-wavelet message.
		If True is returned, go on with processing the next message.
		If False is returned, discard any following messages.
		
		"""
		participant = pconn.participant
		pconn.last_contact = datetime.datetime.now()
		pconn.save()
		
		if message.has_key(u"type"):
			
			if message["type"] == "PING":
				self.emit(pconn, "PONG", message["property"]) # Traditionally
			
			elif message["type"] == "PARTICIPANT_INFO":
				self.logger.info("[%s/%s@manager] Sending participant information" % (participant.name, pconn.id))
				p_info = {}
				for p_id in message["property"]:
					try:
						p_info[p_id] = Participant.objects.get(id=p_id).serialize()
					except ObjectDoesNotExist:
						p_info[p_id] = None
				self.emit(pconn, "PARTICIPANT_INFO", p_info)
			
			elif message["type"] == "PARTICIPANT_SEARCH":
				if len(message["property"]) < getattr(settings, "PARTICIPANT_SEARCH_LENGTH", 0):
					self.emit(pconn, "PARTICIPANT_SEARCH", {"result": "TOO_SHORT", "data": getattr(settings, "PARTICIPANT_SEARCH_LENGTH", 0)})
					self.logger.debug("[%s/%s@manager] Participant search query too short" % (participant.name, pconn.id))
				else:
					self.logger.info("[%s/%s@manager] Performing participant search" % (participant.name, pconn.id))
					
					lst = []
					for p in Participant.objects.filter(name__icontains=message["property"]).exclude(id=participant.id):
						lst.append(p.id)
					self.emit(pconn, "PARTICIPANT_SEARCH", {"result": "OK", "data": lst})
			
			elif message["type"] == "GADGET_LIST":
				all_gadgets = map(lambda g: {"id": g.id, "uploaded_by": g.by_user.participants.all()[0].name, "name": g.title, "descr": g.description, "url": g.url}, Gadget.objects.all())
				self.logger.info("[%s/%s@manager] Sending Gadget list" % (participant.name, pconn.id))
				self.emit(pconn, "GADGET_LIST", all_gadgets)
			
			elif message["type"] == "WAVELET_CREATE":
				if message["property"].get("waveId", "") == "":
					wave = Wave.objects.create_and_init_new_wave(participant, message["property"].get("title", ""))
					self.logger.info("[%s/%s@manager] Created wave '%s'" % (participant.name, pconn.id, wave.id))
					wavelet = wave.root_wavelet()
				else:
					try:
						wave = Wave.objects.get(id=message["property"]["waveId"])
					except ObjectDoesNotExist:
						self.emit(pconn, "ERROR", {"tag": "WAVE_NOT_FOUND", "desc": "A Wave with id '%s' does not exist" % message["property"]["waveId"]})
						self.logger.error("[%s/%s@manager] Cannot create Wavelet; Wave '%s' not found" % (participant.name, pconn.id, message["property"]["waveId"]))
						return True
					wavelet = wave.create_wavelet(participant, message["property"].get("title", ""))
				self.emit(pconn, "WAVELET_CREATED", {"waveId": wave.id, "waveletId": wavelet.id})
				self.logger.info("[%s/%s@manager] Created Wavelet '%s'" % (participant.name, pconn.id, wavelet.id))
			
			elif message["type"] == "WAVE_LIST":
				self.logger.info("[%s/%s@manager] Sending Wave list" % (participant.name, pconn.id))
				waves = {}
				for wavelet in participant.wavelets.all():
					entry = waves.setdefault(wavelet.wave.id, {})
					entry[wavelet.id] = wavelet.serialize()
				self.emit(pconn, "WAVE_LIST", waves)
			
			elif message["type"] == "WAVELET_LIST":
				wave_id = message["property"].get("waveId", "")
				try:
					wave = Wave.objects.get(id=wave_id)
				except ObjectDoesNotExist:
					self.emit(pconn, "ERROR", {"tag": "WAVE_NOT_FOUND", "desc": "A Wave with id '%s' does not exist" % wave_id})
					self.logger.error("[%s/%s@manager] Cannot list Wavelets; Wave '%s' not found" % (participant.name, pconn.id, wave_id))
					return True
				self.logger.info("[%s/%s@manager] Sending Wavelet list for wave '%s'" % (participant.name, pconn.id, wave_id))
				wavelets = {}
				for wavelet in participant.wavelets.filter(wave=wave):
					wavelets[wavelet.id] = wavelet.serialize()
				self.emit(pconn, "WAVELET_LIST", {"waveId": wave_id, "wavelets": wavelets})
			
			elif message["type"] == "DISCONNECT":
				self.logger.info("[%s/%s@manager] Connection to server closed (by client)" % (participant.name, pconn.id))
				self.curr_connections.remove(pconn.id)
				pconn.delete()
				return False
			
			else:
				self.emit(pconn, "ERROR", {"tag": "UNKNOWN_MESSAGE", "desc": "Type '%s' not recognised" % message["type"]})
				self.logger.error("[%s/%s@manager] Unknown message: %s" % (participant.name, pconn.id, message))
		
		else:
			self.emit(pconn, "ERROR", {"tag": "UNKNOWN_MESSAGE", "desc": "Message lacks 'type' field"})
			self.logger.error("[%s/%s@manager] Unknown message: %s" % (participant.name, pconn.id, message))
		
		return True

	def handle_login_message(self, pconn, message):
		"""
		Handle a login message.
		
		pconn is a temporary object which is used to send a reply.
		
		"""
		
		if message.has_key(u"type"):
			
			if message["type"] == "LOGIN":
				user = auth.authenticate(username=message["property"].get("username", ""), password=message["property"].get("password", ""))
				if user != None:
					try:
						participant = Participant.objects.get(user__id=user.id)
					except ObjectDoesNotExist:
						participant = Participant.objects.create_from_user(user)
					# Welcome
					new_pconn = participant.create_new_connection()
					new_pconn.save()
					self.logger.info("[%s/%s@login] Participant logged in via key '%s'" % (participant.name, new_pconn.id, pconn.rx_key))
					self.emit(pconn, "LOGIN", {"rx_key": new_pconn.rx_key, "tx_key": new_pconn.tx_key, "viewer_id": participant.id})
				else:
					self.emit(pconn, "ERROR", {"tag": "LOGIN_FAILED", "desc": "Unknown username or password"})
					self.logger.error("[%s@login] Login failed" % (pconn.rx_key))
			
			else:
				self.emit(pconn, "ERROR", {"tag": "UNKNOWN_MESSAGE", "desc": "Type '%s' not recognised" % message["type"]})
				self.logger.error("[%s@login] Unknown message: %s" % (pconn.rx_key, message))
		
		else:
			self.emit(pconn, "ERROR", {"tag": "UNKNOWN_MESSAGE", "desc": "Message lacks 'type' field"})
			self.logger.error("[%s@login] Unknown message: %s" % (pconn.rx_key, message))

	def broadcast(self, wavelet, type, property, except_connections=[], manager_property=None):
		"""
		Send messages to all participants.
		
		`wavelet` must be a Wavelet object.
		`except_connections` is a list of ParticipantConn objects to be
		excluded from the broadcast.
		
		"""
		msg_dict = {
			"type": type,
			"property": property
		}
		if manager_property:
			mmsg_dict = {
				"type": type,
				"property": manager_property
			}
			mmsg_dict["property"].update({"waveId": wavelet.wave.id, "waveletId": wavelet.id})
		self.logger.debug("Broadcasting Message:\n" + repr(msg_dict))
		for p in wavelet.participants.all():
			for conn in p.connections.all():
				if not conn in except_connections:
					if conn.wavelets.filter(id=wavelet.id).count() > 0: # Connected to this wavelet
						self.out_queue.setdefault(conn.rx_key, []).append(msg_dict)
					elif manager_property != None: # Not connected, send manager message
						self.manager_queue.setdefault(conn.rx_key, []).append(mmsg_dict)
	
	def broadcast_managers(self, wavelet, type, manager_property, except_connections=[], only_unconnected=True):
		mmsg_dict = {
			"type": type,
			"property": manager_property
		}
		mmsg_dict["property"].update({"waveId": wavelet.wave.id, "waveletId": wavelet.id})
		self.logger.debug("Broadcasting Manager Message:\n" + repr(mmsg_dict))
		for p in wavelet.participants.all():
			for conn in p.connections.all():
				if not conn in except_connections:
					if conn.wavelets.filter(id=wavelet.id).count() == 0 or not only_unconnected:
						self.manager_queue.setdefault(conn.rx_key, []).append(mmsg_dict)
	
	def emit(self, to, type, property):
		"""
		Collect messages to be sent.
		`to` must be a ParticipantConn object.
		
		"""
		msg_dict = {
			"type": type,
			"property": property
		}
		try:
			self.logger.debug("Emiting Message to %s/%s:\n%s" % (to.participant.name, to.id, repr(msg_dict)))
		except:
			self.logger.debug("Emiting Message to %s:\n%s" % (to.rx_key, repr(msg_dict)))
		self.out_queue.setdefault(to.rx_key, []).append(msg_dict)
	
	def error(self, to, tag, desc):
		"""
		Collect error messages. See emit.
		
		"""
		msg_dict = {
			"type": "ERROR",
			"property": {
				"tag": tag,
				"desc": desc
			}
		}
		self.out_queue.setdefault(to.rx_key, []).append(msg_dict)
	
	def reply_error(self, conn_key, wavelet_id, tag, desc):
		"""
		Builds an error message to be returned directly by the process method.
		
		"""
		return {
			"%s.%s.waveop" % (conn_key, wavelet_id): {
				"type": "ERROR",
				"property": {
					"tag": tag,
					"descr": desc
				}
			}
		}
	
	def log_stats(self):
		"""
		Writes some statistics to the logfile. This method may be
		called periodically; stats are reset after each call.

		"""
		self.logger.info("""[Statistics]
Bundles processed: %(bundles)s
Curr. connections: %(curr_connections)s
Peak connections:  %(peak_connections)s
Total connections: %(total_connections)s""" % {
			"bundles": self.bundles,
			"curr_connections": len(self.curr_connections),
			"peak_connections": self.peak_connections,
			"total_connections": self.total_connections,
		})
		self.bundles = 0
		self.peak_connections = len(self.curr_connections)
		self.total_connections = 0
	
	def purge_connections(self):
		"""
		This method will check all connections to the server and throw out
		everyone which has timed out.
		This can be run asynchronously every 10 minutes or so.
		
		"""
		for conn in ParticipantConn.objects.all():
			if datetime.datetime.now() > conn.last_contact + self.conn_lifetime:
				conn_id, conn_participant_name = conn.id, conn.participant.name
				for wavelet in conn.wavelets.all():
					wavelet.participant_conns.remove(conn)
					self.logger.info("[%s/%s@%s] Connection to wavelet closed (by timeout)" % (conn.participant.name, conn.id, wavelet.wave.id))
				if conn_id in self.curr_connections:
					self.curr_connections.remove(conn_id)
				conn.delete()
				self.logger.info("[%s/%s] Connection to server closed (by timeout)" % (conn_participant_name, conn_id))

